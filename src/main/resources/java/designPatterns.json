[
    {
        "question": "Which design pattern ensures a class has only one instance and provides a global point of access to it?",
        "correctAnswers": ["Singleton Pattern"],
        "incorrectAnswers": ["Builder Pattern", "Prototype Pattern", "Observer Pattern"],
        "explanation": "The Singleton Pattern restricts instantiation of a class to a single object and provides a global point of access."
    },
    {
        "question": "What design pattern provides an interface for creating families of related objects without specifying their concrete classes?",
        "correctAnswers": ["Abstract Factory Pattern"],
        "incorrectAnswers": ["Factory Method Pattern", "Composite Pattern", "Adapter Pattern"],
        "explanation": "The Abstract Factory Pattern creates families of related objects through a common interface without depending on their concrete implementations."
    },
    {
        "question": "Which pattern involves encapsulating a request as an object, allowing parameterization of clients with requests?",
        "correctAnswers": ["Command Pattern"],
        "incorrectAnswers": ["Strategy Pattern", "Builder Pattern", "Decorator Pattern"],
        "explanation": "The Command Pattern encapsulates a request as an object, enabling operations like queuing and logging requests."
    },
    {
        "question": "What design pattern allows an object to alter its behavior when its internal state changes?",
        "correctAnswers": ["State Pattern"],
        "incorrectAnswers": ["Observer Pattern", "Proxy Pattern", "Chain of Responsibility Pattern"],
        "explanation": "The State Pattern allows an object to change its behavior dynamically based on its current state."
    },
    {
        "question": "Which design pattern provides a surrogate or placeholder for another object to control access to it?",
        "correctAnswers": ["Proxy Pattern"],
        "incorrectAnswers": ["Facade Pattern", "Decorator Pattern", "Composite Pattern"],
        "explanation": "The Proxy Pattern provides a surrogate object to control access to another object."
    },
    {
        "question": "What pattern composes objects into tree structures to represent part-whole hierarchies?",
        "correctAnswers": ["Composite Pattern"],
        "incorrectAnswers": ["Bridge Pattern", "Singleton Pattern", "Prototype Pattern"],
        "explanation": "The Composite Pattern allows individual objects and compositions of objects to be treated uniformly."
    },
    {
        "question": "Which pattern is used to define a family of algorithms, encapsulate each one, and make them interchangeable?",
        "correctAnswers": ["Strategy Pattern"],
        "incorrectAnswers": ["Observer Pattern", "Template Method Pattern", "Command Pattern"],
        "explanation": "The Strategy Pattern defines a family of algorithms and allows the client to choose an appropriate one at runtime."
    },
    {
        "question": "What pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses?",
        "correctAnswers": ["Template Method Pattern"],
        "incorrectAnswers": ["Strategy Pattern", "Command Pattern", "Builder Pattern"],
        "explanation": "The Template Method Pattern defines the structure of an algorithm while allowing subclasses to customize specific steps."
    },
    {
        "question": "Which design pattern separates the construction of a complex object from its representation?",
        "correctAnswers": ["Builder Pattern"],
        "incorrectAnswers": ["Prototype Pattern", "Abstract Factory Pattern", "Flyweight Pattern"],
        "explanation": "The Builder Pattern constructs complex objects step-by-step and isolates the construction process from the final representation."
    },
    {
        "question": "Which pattern provides a unified interface to a set of interfaces in a subsystem?",
        "correctAnswers": ["Facade Pattern"],
        "incorrectAnswers": ["Decorator Pattern", "Adapter Pattern", "Proxy Pattern"],
        "explanation": "The Facade Pattern provides a simplified interface to a complex subsystem, making it easier to use."
    },
    {
        "question": "What pattern allows objects to notify other objects about changes in their state?",
        "correctAnswers": ["Observer Pattern"],
        "incorrectAnswers": ["State Pattern", "Strategy Pattern", "Singleton Pattern"],
        "explanation": "The Observer Pattern establishes a dependency between objects, ensuring updates when the subject's state changes."
    },
    {
        "question": "Which design pattern is based on defining a one-to-many dependency between objects?",
        "correctAnswers": ["Observer Pattern"],
        "incorrectAnswers": ["Command Pattern", "Builder Pattern", "Bridge Pattern"],
        "explanation": "The Observer Pattern allows multiple observers to react automatically to changes in the state of a subject."
    },
    {
        "question": "What pattern uses an object to hide the complexities of a system?",
        "correctAnswers": ["Facade Pattern"],
        "incorrectAnswers": ["Proxy Pattern", "Composite Pattern", "Flyweight Pattern"],
        "explanation": "The Facade Pattern provides a simple interface to a more complex set of functionalities."
    },
    {
        "question": "Which design pattern allows you to create new objects by copying existing ones?",
        "correctAnswers": ["Prototype Pattern"],
        "incorrectAnswers": ["Singleton Pattern", "Builder Pattern", "Factory Method Pattern"],
        "explanation": "The Prototype Pattern allows cloning of objects to create new instances, reducing the need for creating new instances from scratch."
    },
    {
        "question": "Which design pattern shares objects to reduce memory consumption?",
        "correctAnswers": ["Flyweight Pattern"],
        "incorrectAnswers": ["Proxy Pattern", "Decorator Pattern", "Abstract Factory Pattern"],
        "explanation": "The Flyweight Pattern shares objects to support a large number of objects with less memory overhead."
    },
    {
        "question": "Which pattern decouples an abstraction from its implementation so the two can vary independently?",
        "correctAnswers": ["Bridge Pattern"],
        "incorrectAnswers": ["Adapter Pattern", "Composite Pattern", "Flyweight Pattern"],
        "explanation": "The Bridge Pattern separates the abstraction and implementation, promoting flexibility and reusability."
    },
    {
        "question": "Which pattern dynamically adds new responsibilities to an object at runtime?",
        "correctAnswers": ["Decorator Pattern"],
        "incorrectAnswers": ["Adapter Pattern", "Strategy Pattern", "Proxy Pattern"],
        "explanation": "The Decorator Pattern allows dynamic addition of responsibilities to an object without altering its structure."
    },
    {
        "question": "What pattern converts the interface of a class into another interface that clients expect?",
        "correctAnswers": ["Adapter Pattern"],
        "incorrectAnswers": ["Bridge Pattern", "Composite Pattern", "Decorator Pattern"],
        "explanation": "The Adapter Pattern translates the interface of a class into a form compatible with the client's expectations."
    },
    {
        "question": "Which design pattern ensures requests are processed by a sequence of handlers?",
        "correctAnswers": ["Chain of Responsibility Pattern"],
        "incorrectAnswers": ["Command Pattern", "Observer Pattern", "Builder Pattern"],
        "explanation": "The Chain of Responsibility Pattern allows requests to be handled by a chain of handlers, promoting loose coupling."
    },
    {
        "question": "Which design pattern provides a way to access elements of an aggregate object sequentially without exposing its structure?",
        "correctAnswers": ["Iterator Pattern"],
        "incorrectAnswers": ["Visitor Pattern", "Command Pattern", "State Pattern"],
        "explanation": "The Iterator Pattern allows traversal of a collection without exposing its underlying representation."
    },
    {
        "question": "Which design pattern defines an interface for creating an object but allows subclasses to alter the type of objects that will be created?",
        "correctAnswers": ["Factory Method Pattern"],
        "incorrectAnswers": ["Builder Pattern", "Abstract Factory Pattern", "Prototype Pattern"],
        "explanation": "The Factory Method Pattern defines an interface for object creation but delegates the actual instantiation to subclasses."
    },
    {
        "question": "Which design pattern defines a dependency between objects so that when one changes state, all its dependents are notified?",
        "correctAnswers": ["Observer Pattern"],
        "incorrectAnswers": ["Decorator Pattern", "State Pattern", "Template Method Pattern"],
        "explanation": "The Observer Pattern ensures that changes to one object propagate to its dependents automatically."
    },
    {
        "question": "What design pattern allows a group of algorithms to be interchangeable within a class structure?",
        "correctAnswers": ["Strategy Pattern"],
        "incorrectAnswers": ["State Pattern", "Command Pattern", "Adapter Pattern"],
        "explanation": "The Strategy Pattern allows algorithms to be swapped dynamically during runtime."
    },
    {
        "question": "Which pattern decouples the construction of a complex object from its representation?",
        "correctAnswers": ["Builder Pattern"],
        "incorrectAnswers": ["Factory Method Pattern", "Prototype Pattern", "Command Pattern"],
        "explanation": "The Builder Pattern isolates the object construction process from the object itself, enabling greater flexibility."
    },
    {
        "question": "Which pattern defines a family of related algorithms and makes them interchangeable without modifying the client?",
        "correctAnswers": ["Strategy Pattern"],
        "incorrectAnswers": ["Template Method Pattern", "Visitor Pattern", "Proxy Pattern"],
        "explanation": "The Strategy Pattern lets the algorithm vary independently from the clients that use it."
    },
    {
        "question": "What pattern provides a simplified interface to a larger body of code, making the subsystem easier to use?",
        "correctAnswers": ["Facade Pattern"],
        "incorrectAnswers": ["Composite Pattern", "Decorator Pattern", "Flyweight Pattern"],
        "explanation": "The Facade Pattern offers a high-level interface for a subsystem, simplifying its usage for clients."
    },
    {
        "question": "Which pattern uses a prototype instance to create new objects by copying the prototype?",
        "correctAnswers": ["Prototype Pattern"],
        "incorrectAnswers": ["Factory Method Pattern", "Singleton Pattern", "Builder Pattern"],
        "explanation": "The Prototype Pattern creates new objects by copying an existing prototype instance."
    },
    {
        "question": "Which design pattern involves passing a request along a chain of potential handlers?",
        "correctAnswers": ["Chain of Responsibility Pattern"],
        "incorrectAnswers": ["Command Pattern", "Iterator Pattern", "Template Method Pattern"],
        "explanation": "The Chain of Responsibility Pattern allows multiple objects to process a request in a chain until it's handled."
    },
    {
        "question": "Which pattern provides a way to access elements of a collection without exposing its underlying structure?",
        "correctAnswers": ["Iterator Pattern"],
        "incorrectAnswers": ["Visitor Pattern", "Strategy Pattern", "Flyweight Pattern"],
        "explanation": "The Iterator Pattern enables sequential access to collection elements without exposing the internal details of the collection."
    },
    {
        "question": "What pattern encapsulates a set of operations to be performed on an object structure and allows new operations to be defined without changing the classes of the elements on which it operates?",
        "correctAnswers": ["Visitor Pattern"],
        "incorrectAnswers": ["Iterator Pattern", "Strategy Pattern", "Observer Pattern"],
        "explanation": "The Visitor Pattern allows defining new operations on an object structure without modifying the structure itself."
    },
    {
        "question": "Which pattern ensures that a single instance of a class is created and provides a global point of access to it?",
        "correctAnswers": ["Singleton Pattern"],
        "incorrectAnswers": ["Builder Pattern", "Prototype Pattern", "Chain of Responsibility Pattern"],
        "explanation": "The Singleton Pattern restricts a class to a single instance and provides global access to it."
    },
    {
        "question": "Which design pattern combines several objects into a single object and allows treating individual objects and composites uniformly?",
        "correctAnswers": ["Composite Pattern"],
        "incorrectAnswers": ["Adapter Pattern", "Flyweight Pattern", "Facade Pattern"],
        "explanation": "The Composite Pattern lets clients treat individual objects and object groups in the same way."
    },
    {
        "question": "Which pattern defines a structure that bridges the gap between two incompatible interfaces?",
        "correctAnswers": ["Adapter Pattern"],
        "incorrectAnswers": ["Bridge Pattern", "Composite Pattern", "Flyweight Pattern"],
        "explanation": "The Adapter Pattern works as a bridge between two incompatible interfaces, allowing them to work together."
    },
    {
        "question": "Which pattern uses a single class that has static methods to create objects for various classes?",
        "correctAnswers": ["Factory Method Pattern"],
        "incorrectAnswers": ["Abstract Factory Pattern", "Prototype Pattern", "Command Pattern"],
        "explanation": "The Factory Method Pattern provides a way to use a single class to create instances of other classes."
    },
    {
        "question": "Which pattern is focused on simplifying code by reusing and sharing as much as possible?",
        "correctAnswers": ["Flyweight Pattern"],
        "incorrectAnswers": ["Decorator Pattern", "Bridge Pattern", "Composite Pattern"],
        "explanation": "The Flyweight Pattern optimizes memory usage by sharing as much data as possible among multiple objects."
    },
    {
        "question": "Which pattern allows a client to use a specific algorithm without changing the logic of its implementation?",
        "correctAnswers": ["Strategy Pattern"],
        "incorrectAnswers": ["State Pattern", "Observer Pattern", "Template Method Pattern"],
        "explanation": "The Strategy Pattern enables dynamic selection of an algorithm without altering the client's behavior."
    },
    {
        "question": "Which pattern dynamically adds or modifies the behavior of an object without changing its structure?",
        "correctAnswers": ["Decorator Pattern"],
        "incorrectAnswers": ["Adapter Pattern", "Composite Pattern", "Flyweight Pattern"],
        "explanation": "The Decorator Pattern allows for the dynamic addition or modification of an object's behavior while preserving its structure."
    },
    {
        "question": "Which pattern is used to represent a group of objects that are treated the same way as a single instance?",
        "correctAnswers": ["Composite Pattern"],
        "incorrectAnswers": ["Proxy Pattern", "Facade Pattern", "Flyweight Pattern"],
        "explanation": "The Composite Pattern groups objects into tree structures to represent part-whole hierarchies."
    },
    {
        "question": "What design pattern is used to define the steps of an algorithm and allow subclasses to override certain steps without changing the algorithm's structure?",
        "correctAnswers": ["Template Method Pattern"],
        "incorrectAnswers": ["Strategy Pattern", "Command Pattern", "Builder Pattern"],
        "explanation": "The Template Method Pattern defines the steps of an algorithm while allowing specific steps to be overridden by subclasses."
    },
    {
        "question": "Which design pattern uses a lightweight object to minimize memory usage for repetitive or similar objects?",
        "correctAnswers": ["Flyweight Pattern"],
        "incorrectAnswers": ["Adapter Pattern", "Composite Pattern", "Abstract Factory Pattern"],
        "explanation": "The Flyweight Pattern reduces memory usage by sharing and reusing lightweight objects."
    }
]