[
    {
        "question": "What is the main purpose of the decorator design pattern?",
        "correctAnswers": ["To add behavior to an object dynamically"],
        "incorrectAnswers": ["To replace the object with a new one", "To simplify complex objects", "To create immutable objects"],
        "explanation": "The decorator design pattern allows you to add new functionality to an object at runtime without altering its structure."
    },
    {
        "question": "Which of the following is a key benefit of using the decorator pattern?",
        "correctAnswers": ["Flexibility to add responsibilities to an object"],
        "incorrectAnswers": ["Improved performance of the object", "Simplification of the codebase", "Guaranteed thread-safety of objects"],
        "explanation": "The decorator pattern provides flexibility to add or modify an object's behavior dynamically, allowing for more modular and maintainable code."
    },
    {
        "question": "What is a typical scenario for using the decorator pattern?",
        "correctAnswers": ["When different objects require similar behaviors but not in all cases"],
        "incorrectAnswers": ["When you want to replace objects in a collection", "When the object needs to be cloned", "When you want to completely refactor the object"],
        "explanation": "The decorator pattern is used when objects require additional behaviors that should be added selectively, rather than altering the object's base functionality."
    },
    {
        "question": "Which design principle does the decorator pattern promote?",
        "correctAnswers": ["Open/closed principle"],
        "incorrectAnswers": ["Single responsibility principle", "Dependency inversion principle", "Interface segregation principle"],
        "explanation": "The decorator pattern supports the open/closed principle, as it allows classes to be extended without modifying their existing code."
    },
    {
        "question": "How does the decorator pattern differ from inheritance?",
        "correctAnswers": ["It allows dynamic behavior modification without altering the object's structure"],
        "incorrectAnswers": ["It creates a hierarchy of classes with shared behaviors", "It requires subclasses to inherit from the base class", "It relies on static binding of behaviors to the class"],
        "explanation": "Unlike inheritance, the decorator pattern allows you to add functionality to an object at runtime without needing to modify its class."
    },
    {
        "question": "Which of the following is a typical structure in the decorator pattern?",
        "correctAnswers": ["Component, ConcreteComponent, Decorator, ConcreteDecorator"],
        "incorrectAnswers": ["Observer, Subject, ConcreteSubject", "Factory, AbstractFactory, ConcreteFactory", "Singleton, Instance"],
        "explanation": "The decorator pattern involves a Component interface, ConcreteComponent that implements the interface, and Decorators that add new functionality to the component."
    },
    {
        "question": "In the decorator pattern, what is the role of the ConcreteDecorator?",
        "correctAnswers": ["To add specific behavior to the component"],
        "incorrectAnswers": ["To initialize the component", "To manage the lifecycle of the component", "To control access to the component"],
        "explanation": "ConcreteDecorators extend the base decorator class and add specific functionality to the component at runtime."
    },
    {
        "question": "What is one downside of the decorator pattern?",
        "correctAnswers": ["It can lead to a large number of small classes"],
        "incorrectAnswers": ["It makes the code harder to test", "It introduces tight coupling between classes", "It requires frequent use of global variables"],
        "explanation": "One downside of the decorator pattern is that it can result in an excessive number of small classes, making the codebase harder to manage."
    },
    {
        "question": "Which of the following best describes a decorator class?",
        "correctAnswers": ["It wraps another object to add behavior"],
        "incorrectAnswers": ["It creates a new object that replaces the original", "It only adds data storage capabilities", "It manages all objects of the same type"],
        "explanation": "A decorator class wraps the original object and adds additional behavior or responsibilities to it dynamically."
    },
    {
        "question": "Which design pattern is similar to the decorator pattern but focuses on creating new classes through inheritance?",
        "correctAnswers": ["The strategy pattern"],
        "incorrectAnswers": ["The observer pattern", "The composite pattern", "The factory pattern"],
        "explanation": "The strategy pattern is similar in that it allows different behaviors, but it relies on creating subclasses to encapsulate the behaviors, whereas decorators dynamically modify an object's behavior."
    },
    {
        "question": "What is a common drawback when using the decorator pattern excessively?",
        "correctAnswers": ["The code can become difficult to understand and maintain"],
        "incorrectAnswers": ["The behavior of the system is locked and cannot be modified", "It leads to the system becoming more rigid and less adaptable", "The system can become too simple to handle complex behaviors"],
        "explanation": "Excessive use of decorators can make the system's behavior hard to track, as it becomes difficult to follow the chain of decorators."
    },
    {
        "question": "How does the decorator pattern improve code maintainability?",
        "correctAnswers": ["By allowing behavior to be added without modifying existing code"],
        "incorrectAnswers": ["By reducing the need for multiple classes", "By centralizing behavior changes in a single place", "By eliminating the need for interfaces"],
        "explanation": "The decorator pattern improves maintainability by allowing new behavior to be added at runtime, making the system more modular and flexible."
    },
    {
        "question": "Which of the following is a common real-world example of the decorator pattern?",
        "correctAnswers": ["Adding features to a coffee order, such as milk or sugar"],
        "incorrectAnswers": ["User authentication in a web application", "File input/output operations", "Managing a database connection pool"],
        "explanation": "A real-world example of the decorator pattern is adding features to a basic object, like adding milk or sugar to a basic coffee order."
    },
    {
        "question": "Which type of relationship exists between a decorator and the component it decorates?",
        "correctAnswers": ["Has-a"],
        "incorrectAnswers": ["Is-a", "Contains", "Uses"],
        "explanation": "A decorator has a 'has-a' relationship with the component it decorates, as it contains a reference to the original component and adds functionality to it."
    },
    {
        "question": "In the decorator pattern, how is behavior added to an object?",
        "correctAnswers": ["By wrapping the object in a decorator"],
        "incorrectAnswers": ["By overriding methods in the object's class", "By directly modifying the object's class", "By calling a factory to create a new object"],
        "explanation": "In the decorator pattern, behavior is added by wrapping the object in a decorator class that adds new functionality."
    },
    {
        "question": "What is a key difference between the decorator pattern and the proxy pattern?",
        "correctAnswers": ["The decorator adds behavior, while the proxy controls access"],
        "incorrectAnswers": ["The proxy pattern modifies the object's data, while the decorator does not", "The decorator pattern controls object access, while the proxy adds functionality", "The proxy pattern requires multiple decorators"],
        "explanation": "The decorator pattern adds behavior to an object, while the proxy pattern controls access to the object, often for purposes like lazy loading or access control."
    },
    {
        "question": "Which of the following is true about using multiple decorators?",
        "correctAnswers": ["Each decorator adds a distinct behavior to the object"],
        "incorrectAnswers": ["The decorators must always be applied in a specific order", "Only one decorator can be used at a time", "All decorators must implement the same interface as the object being decorated"],
        "explanation": "Multiple decorators can be applied to an object, with each one adding distinct behavior, and they can be applied in any order."
    },
    {
        "question": "What is a primary advantage of the decorator pattern over subclassing?",
        "correctAnswers": ["It avoids the creation of large, complex inheritance hierarchies"],
        "incorrectAnswers": ["It is less flexible than subclassing", "It relies on global state management", "It always creates multiple instances of the object"],
        "explanation": "The decorator pattern avoids the need for complex inheritance hierarchies by dynamically adding behavior to objects at runtime."
    }
]
