[
    {
      "question": "What is the primary purpose of the Strategy design pattern?",
      "correctAnswers": ["To encapsulate algorithms into separate classes"],
      "incorrectAnswers": [
        "To bind algorithms to specific classes permanently",
        "To create a single static method for an algorithm",
        "To eliminate the need for multiple interfaces in a program"
      ],
      "explanation": "The Strategy design pattern allows encapsulation of algorithms into separate classes, making them interchangeable without altering the client code."
    },
    {
      "question": "How does the Strategy pattern promote flexibility in a program?",
      "correctAnswers": ["By allowing algorithms to be interchangeable"],
      "incorrectAnswers": [
        "By reducing the number of algorithms in a program",
        "By binding algorithms directly to the context",
        "By replacing inheritance with static methods"
      ],
      "explanation": "The Strategy pattern promotes flexibility by enabling the client to switch between different algorithms at runtime."
    },
    {
      "question": "Which role does the Context class play in the Strategy pattern?",
      "correctAnswers": ["It delegates behavior to a Strategy object"],
      "incorrectAnswers": [
        "It implements all the algorithms directly",
        "It provides abstract methods for Strategies to inherit",
        "It defines the algorithm's logic in a static context"
      ],
      "explanation": "The Context class in the Strategy pattern holds a reference to a Strategy object and delegates behavior to it."
    },
    {
      "question": "What is the key benefit of using the Strategy design pattern?",
      "correctAnswers": ["It simplifies code maintenance by separating algorithms"],
      "incorrectAnswers": [
        "It merges algorithms into a single class for simplicity",
        "It eliminates the need for abstract classes",
        "It reduces runtime performance to achieve simplicity"
      ],
      "explanation": "The Strategy pattern separates algorithms into different classes, making them easier to maintain and extend."
    },
    {
      "question": "How are algorithms represented in the Strategy design pattern?",
      "correctAnswers": ["As concrete implementations of a Strategy interface"],
      "incorrectAnswers": [
        "As static methods within a single utility class",
        "As anonymous classes inside the Context class",
        "As private methods within the client class"
      ],
      "explanation": "In the Strategy design pattern, algorithms are implemented as concrete classes that adhere to a common Strategy interface."
    },
    {
      "question": "When should you consider using the Strategy design pattern?",
      "correctAnswers": ["When a class has multiple behaviors that can change at runtime"],
      "incorrectAnswers": [
        "When a single algorithm needs to be reused across all contexts",
        "When all behaviors are static and fixed",
        "When the application requires no polymorphism"
      ],
      "explanation": "The Strategy pattern is ideal when a class must support multiple interchangeable behaviors or algorithms at runtime."
    },
    {
      "question": "What problem does the Strategy pattern solve?",
      "correctAnswers": ["Avoiding conditional statements for selecting algorithms"],
      "incorrectAnswers": [
        "Reducing the size of classes by using fewer methods",
        "Eliminating inheritance completely in object-oriented design",
        "Allowing direct access to private fields of the Context class"
      ],
      "explanation": "The Strategy pattern eliminates the need for complex conditional statements by encapsulating algorithms in separate classes."
    },
    {
      "question": "Which of these is NOT a component of the Strategy pattern?",
      "correctAnswers": ["Observer"],
      "incorrectAnswers": [
        "Context",
        "Strategy interface",
        "Concrete Strategy"
      ],
      "explanation": "The Observer pattern is unrelated to the Strategy pattern, which consists of Context, Strategy interface, and Concrete Strategies."
    },
    {
      "question": "How does the Strategy design pattern adhere to the Open/Closed Principle?",
      "correctAnswers": ["By allowing new algorithms to be added without modifying existing code"],
      "incorrectAnswers": [
        "By making algorithms immutable once created",
        "By reducing the need for polymorphism in the codebase",
        "By ensuring all methods are private and unchangeable"
      ],
      "explanation": "The Strategy pattern adheres to the Open/Closed Principle by enabling new algorithms to be introduced without altering existing code."
    },
    {
      "question": "What is a drawback of the Strategy pattern?",
      "correctAnswers": ["It increases the number of classes in a program"],
      "incorrectAnswers": [
        "It prevents algorithms from being reused in different contexts",
        "It makes algorithms harder to test independently",
        "It eliminates runtime flexibility in the code"
      ],
      "explanation": "The Strategy pattern can increase the number of classes in a system, as each algorithm is implemented as a separate class."
    },
    {
      "question": "How does the client specify which algorithm to use in the Strategy pattern?",
      "correctAnswers": ["By setting a Strategy object in the Context"],
      "incorrectAnswers": [
        "By defining the algorithm within the Context class",
        "By passing the algorithm directly to the Strategy interface",
        "By using a static reference to the desired Strategy class"
      ],
      "explanation": "The client specifies the algorithm by assigning a Strategy object to the Context, which then delegates calls to the Strategy."
    },
    {
      "question": "Which of the following best describes the Strategy pattern?",
      "correctAnswers": ["A behavioral design pattern"],
      "incorrectAnswers": [
        "A creational design pattern",
        "A structural design pattern",
        "A concurrency design pattern"
      ],
      "explanation": "The Strategy pattern is a behavioral design pattern because it manages how objects interact and change behavior dynamically."
    },
    {
      "question": "How are different strategies selected in the Strategy pattern?",
      "correctAnswers": ["At runtime by the Context or client"],
      "incorrectAnswers": [
        "At compile-time by static method calls",
        "At runtime through hard-coded conditions",
        "By initializing a single static instance in the Context"
      ],
      "explanation": "The Strategy pattern allows the client or Context to select different strategies dynamically at runtime."
    },
    {
      "question": "What principle is reinforced by the Strategy pattern?",
      "correctAnswers": ["Program to an interface, not an implementation"],
      "incorrectAnswers": [
        "Use inheritance over composition",
        "Bind behavior to specific implementations",
        "Write algorithms as tightly coupled to client classes"
      ],
      "explanation": "The Strategy pattern promotes programming to an interface, enabling flexibility and adherence to good design principles."
    },
    {
      "question": "Which design problem is addressed by using the Strategy pattern?",
      "correctAnswers": ["Making behavior reusable and interchangeable"],
      "incorrectAnswers": [
        "Minimizing the number of subclasses in a hierarchy",
        "Creating immutable objects with fixed behavior",
        "Defining private methods within a single utility class"
      ],
      "explanation": "The Strategy pattern addresses the need to make behavior reusable and interchangeable by encapsulating it in separate classes."
    },
    {
      "question": "What is the relationship between Context and Strategy in the Strategy pattern?",
      "correctAnswers": ["The Context uses a Strategy to execute behavior"],
      "incorrectAnswers": [
        "The Context inherits from the Strategy interface",
        "The Strategy class defines the Context's lifecycle",
        "The Strategy directly modifies the state of the Context"
      ],
      "explanation": "In the Strategy pattern, the Context delegates specific behaviors to a Strategy object."
    },
    {
      "question": "Which of the following is an example of the Strategy pattern?",
      "correctAnswers": ["Different payment methods in an e-commerce platform"],
      "incorrectAnswers": [
        "Implementing a database connection pool",
        "Providing singleton access to a logging utility",
        "Defining a factory method for object creation"
      ],
      "explanation": "The Strategy pattern is exemplified by systems like e-commerce platforms, where different payment methods can be chosen dynamically."
    },
    {
      "question": "What distinguishes the Strategy pattern from inheritance-based approaches?",
      "correctAnswers": ["It uses composition to change behavior dynamically"],
      "incorrectAnswers": [
        "It uses abstract classes to implement behavior once",
        "It eliminates the need for polymorphism",
        "It relies solely on static methods for flexibility"
      ],
      "explanation": "The Strategy pattern relies on composition rather than inheritance, allowing behavior to change dynamically at runtime."
    },
    {
      "question": "How is behavior typically encapsulated in the Strategy design pattern?",
      "correctAnswers": ["In separate classes implementing a common interface"],
      "incorrectAnswers": [
        "In static methods defined within the Context class",
        "In nested private classes within the client code",
        "In anonymous inner classes within a utility package"
      ],
      "explanation": "Behavior in the Strategy pattern is encapsulated in separate classes that implement a common interface, ensuring modularity."
    },
    {
      "question": "What makes the Strategy pattern different from the Template Method pattern?",
      "correctAnswers": ["Strategy uses composition; Template Method uses inheritance"],
      "incorrectAnswers": [
        "Strategy relies on inheritance; Template Method relies on composition",
        "Strategy eliminates the need for abstract classes, unlike Template Method",
        "Strategy applies to structural changes, while Template Method applies to concurrency"
      ],
      "explanation": "The Strategy pattern relies on composition to vary behavior, whereas the Template Method pattern uses inheritance to define a fixed structure."
    }
  ]
  